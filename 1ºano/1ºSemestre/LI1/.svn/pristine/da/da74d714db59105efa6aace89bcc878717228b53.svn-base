-- | Este módulo define funções comuns da Tarefa 2 do trabalho prático.
module Tarefa2_2018li1g002 where

import LI11819
import Tarefa0_2018li1g002
import Tarefa1_2018li1g002

-- * Testes

-- | Testes unitários da Tarefa 2.
--
-- Cada teste é um triplo (/identificador do 'Jogador'/,/'Jogada' a efetuar/,/'Estado' anterior/).
testesT2 :: [(Int,Jogada,Estado)]
testesT2 = [(1,Movimenta D,(Estado (mapaInicial (20,20)) [(Jogador (2,2) C 3 3 3),(Jogador (1,1) C 3 3 3),(Jogador (4,4) B 2 2 2)] [(DisparoCanhao 1 (2,2) D), (DisparoLaser 1 (2,2) E),(DisparoChoque 1 3),(DisparoLaser 0 (3,3) E)]))]

-- * Funções principais da Tarefa 2.

-- | Efetua uma jogada.
jogada :: Int -- ^ O identificador do 'Jogador' que efetua a jogada.
       -> Jogada -- ^ A 'Jogada' a efetuar.
       -> Estado -- ^ O 'Estado' anterior.
       -> Estado -- ^ O 'Estado' resultante após o jogador efetuar a jogada.
jogada x (Movimenta h) e = e{jogadoresEstado = atualizaIndiceLista x (podeMover l (mapaEstado e) h (jogadoresEstado e)) (jogadoresEstado e)}
                          where l = encontraIndiceLista x (jogadoresEstado e)
jogada x (Dispara h) e = e{jogadoresEstado = atualizaIndiceLista x (municao l h) (jogadoresEstado e), disparosEstado = atualizaIndiceLista x (posiDisparo l n) (disparosEstado e)}
                            where l = encontraIndiceLista x (jogadoresEstado e)
                                  n = encontraJogador x h (disparosEstado e)

encontraJogador :: Int -> Arma -> [Disparo] -> Disparo
encontraJogador x Canhao ((DisparoCanhao a b c):t) | x == a = (DisparoCanhao a b c)
                                                   | otherwise = encontraJogador x Canhao t
encontraJogador x Laser ((DisparoLaser a b c):t) | x == a = (DisparoLaser a b c)
                                                 | otherwise = encontraJogador x Laser t
encontraJogador x Choque ((DisparoChoque a b):t) | x == a = (DisparoChoque a b)
                                                 | otherwise = encontraJogador x Choque t
encontraJogador x Canhao ((DisparoLaser a b c):t) = encontraJogador x Canhao t
encontraJogador x Canhao ((DisparoChoque a b):t) = encontraJogador x Canhao t
encontraJogador x Laser ((DisparoCanhao a b c):t) = encontraJogador x Laser t
encontraJogador x Laser ((DisparoChoque a b):t) = encontraJogador x Laser t
encontraJogador x Choque ((DisparoCanhao a b c):t) = encontraJogador x Choque t
encontraJogador x Choque ((DisparoLaser a b c):t) = encontraJogador x Choque t

posiDisparo :: Jogador -> Disparo -> Disparo
posiDisparo (Jogador (x,y) h _ _ _) (DisparoCanhao a _ b) = (DisparoCanhao a (somaVetores (x,y) (direcaoParaVetor h)) b)
posiDisparo (Jogador (x,y) h _ _ _) (DisparoLaser a _ b) = (DisparoLaser a (somaVetores (x,y) (direcaoParaVetor h)) b)
posiDisparo _ (DisparoChoque a b) = (DisparoChoque a b)

municao :: Jogador -> Arma -> Jogador
municao (Jogador q w a b e) Laser | a>0 && b>0 = (Jogador q w a (b-1) e)
                                  | otherwise = (Jogador q w a b e)
municao (Jogador q w a e b) Choque | a>0 && a<=5 && b>0 = (Jogador q w a e (b-1))
                                   | otherwise = (Jogador q w a e b)



{--Movimenta o tanque para uma certa posicao, conforme a direcao, caso esse posicao
esteja Vazio, ou seja, o tanque so é movimentado para essa posicao se nesta posicao
nao tenha nenhum tipo de Bloco (Destrutivel ou Indestrutivel) ou nenhum outro tanque--}
podeMover :: Jogador -> Mapa -> Direcao -> [Jogador] -> Jogador
podeMover (Jogador (x,y) k a b c) m C l | buscarMatriz (x-1,y) m && podeAvancar (Jogador (x,y) k a b c) C l = (Jogador (x-1,y) C a b c)
                                        | otherwise = (Jogador (x,y) C a b c) 
podeMover (Jogador (x,y) k a b c) m D l | buscarMatriz (x,y+1) m && podeAvancar (Jogador (x,y) k a b c) D l = (Jogador (x,y+1) D a b c)
                                        | otherwise = (Jogador (x,y) D a b c) 
podeMover (Jogador (x,y) k a b c) m B l | buscarMatriz (x+1,y) m && podeAvancar (Jogador (x,y) k a b c) B l = (Jogador (x+1,y) B a b c)
                                        | otherwise = (Jogador (x,y) B a b c) 
podeMover (Jogador (x,y) k a b c) m E l | buscarMatriz (x,y-1) m && podeAvancar (Jogador (x,y) k a b c) E l = (Jogador (x,y-1) E a b c)
                                        | otherwise = (Jogador (x,y) E a b c) 

{--Vai ao mapa verificar se o tanque pode se mover para uma posicao,ou seja, vai verificar
se numa certa posicao é um Bloco (Destrutivel ou Insdestrutivel) ou é Vazia, 
caso seja Bloco devolve um False (que significa que o tanque nao se pode movimentar para
essa possicao) e caso seja Vazia (significa que o tanque pode se movimentar para essa posicao--}
buscarMatriz :: Posicao -> Mapa -> Bool
buscarMatriz (0,0) ((h:t):ts) | h== Vazia = True
                              | otherwise = False
buscarMatriz _ [] = False
buscarMatriz (0,y) ((h:t):ts) = buscarMatriz (0,y-1) (t:ts)
buscarMatriz (x,y) ((h:t):ts) = buscarMatriz (x-1,y) ts

{--Verifica se na posicao em que o tanque vai se mover existe outro tanque, caso exista
um outro tanque devolve um False(que quer dizer que nao se pode movimentar), caso nao exista
devolve um True (que significa que se pode movimentar)--}
podeAvancar :: Jogador -> Direcao -> [Jogador] -> Bool
podeAvancar _ _ [] = True
podeAvancar (Jogador (x,y) a b c d) C ((Jogador (q,w) _ _ _ _):t) | (x-2,y) == (q,w) = False
                                                                  | otherwise = podeAvancar (Jogador (x,y) a b c d) C t
podeAvancar (Jogador (x,y) a b c d) D ((Jogador (q,w) _ _ _ _):t) | (x,y+2) == (q,w) = False
                                                                  | otherwise = podeAvancar (Jogador (x,y) a b c d) D t
podeAvancar (Jogador (x,y) a b c d) B ((Jogador (q,w) _ _ _ _):t) | (x+2,y) == (q,w) = False
                                                                  | otherwise = podeAvancar (Jogador (x,y) a b c d) B t
podeAvancar (Jogador (x,y) a b c d) E ((Jogador (q,w) _ _ _ _):t) | (x,y-2) == (q,w) = False
                                                                  | otherwise = podeAvancar (Jogador (x,y) a b c d) E t



 