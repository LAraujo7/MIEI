-- | Este módulo define funções comuns da Tarefa 3 do trabalho prático.
module Tarefa3_2018li1g002 where

import LI11819
import Data.Char
import Tarefa0_2018li1g002
import Tarefa1_2018li1g002
import Tarefa2_2018li1g002

-- * Testes
{--                         Pedimos desculpa stor, nao conseguimos para documentar esta tarefa a tempo                              --}
-- | Testes unitários da Tarefa 3.
--
-- Cada teste é um 'Estado'.
testesT3 :: [Estado]
testesT3 = [(Estado ([[Bloco Indestrutivel,Bloco Indestrutivel,Bloco Indestrutivel,Bloco Indestrutivel,Bloco Indestrutivel],[Bloco Indestrutivel,Vazia,Bloco Destrutivel,Bloco Destrutivel,Bloco Indestrutivel],[Bloco Indestrutivel,Vazia,Vazia,Vazia,Bloco Indestrutivel],[Bloco Indestrutivel,Bloco Indestrutivel,Bloco Destrutivel,Vazia,Bloco Indestrutivel],[Bloco Indestrutivel,Bloco Indestrutivel,Bloco Indestrutivel,Bloco Indestrutivel,Bloco Indestrutivel]]) ([(Jogador (2,42) D 3 2 1),(Jogador (4,3) E 2 1 1),(Jogador (2,2) B 33 3 3)]) ([(DisparoCanhao 16 (3,39) B),(DisparoChoque 3 92),(DisparoLaser 2 (21,2) C)]))]


-- * Funções principais da Tarefa 3.

-- | Comprime um 'Estado' para formato textual.
--
-- __NB:__ A função 'show' representa um 'Estado' num formato textual facilmente legível mas extenso.
--
-- __NB:__ Uma boa solução deve representar o 'Estado' dado no mínimo número de caracteres possível.
comprime :: Estado -> String
comprime e = total (mapaEstado e) ++ " " ++ comprimirLista (jogadoresEstado e) ++ " " ++ comprimeDisparosCLH (disparosEstado e)

 {- | Para comprimir o mapa a minha estragia foi a seguinte : 
      * Primeiro retirar as bordas do mapa, pos ja sabemos que este tem sempre os blocos indestrutiveis, para isso
 ultizei a funcao 'retirarBoradas' que tem como auxiliar as seguintes funcoes : 'antesDeComprimir','aDC','retirar1C','retirar2C'. 
      * Apos retirar as bordas, começei por transformar os "Blocos Indestrutivel" em apenas uma letra 'i', 
os "Blocos Destrutivel" em 'd', e os blocos "Vazia" em 'v', utilizando as funcoes : 'comprimeMapa' e 'comprimeLinha'
      * Para comprimir ainda mais o mapa usei as funcoes 'constroiMSet' e 'cM' que verifica se os blocos a sua direita sao iguais
caso sejam, ao primeiro este blocos de agrupam e formam assim um set de blocos (por exemplo : "vvvv" sera agora "4v").
      * De seguida, como para descomprimir vou precisar da dimensao do mapa, pois ira ser necessario colocar as bordas de volta,
decidi entao tambem colocar a dimensao do mapa na comprensao do mapa, para isso utilizei as funcoes 'dimensaoMapa','dimensaoMapa',
e 'mapaString'.
      * Para finalizar juntei a funcao que comprimia o mapa com a funcao que comprimia a dimensao do mapa, formando assim
a funcao final da comprensao do mapa, a funcao 'total'.-} 
antesDeComprimir :: Mapa -> Mapa
antesDeComprimir [] = []
antesDeComprimir l = (drop 1 l)

aDC :: Mapa -> Mapa
aDC [] = []
aDC l =  (take ((length l)-1) l)

retirar1C :: Mapa -> Mapa
retirar1C [] = []
retirar1C (h:t) = (drop 1 h) : retirar1C t

retirar2C :: Mapa -> Mapa
retirar2C [] = []
retirar2C (h:t) = (take ((length h)-1) h):retirar2C t


retirarBordas :: Mapa -> Mapa
retirarBordas [] = []
retirarBordas l = antesDeComprimir (aDC (retirar1C (retirar2C l)))


------------------

comprimeMapa :: Mapa -> String
comprimeMapa [] = []
comprimeMapa (l:t) = (comprimeLinha l) ++ comprimeMapa t

comprimeLinha :: [Peca] -> String
comprimeLinha [] = []
comprimeLinha (h:t) | h == x = "i" ++ comprimeLinha t
                    | h == y = "d" ++ comprimeLinha t
                    | otherwise = "v" ++ comprimeLinha t
                    where x = Bloco Indestrutivel
                          y = Bloco Destrutivel

constroiMSet' :: String -> String
constroiMSet' [] = []
constroiMSet' (h:t) = show ((cM 1 h t)+1) ++ [h] ++ constroiMSet' (drop (cM 1 h t) t)

cM :: Int -> Char -> String -> Int
cM x h [] = 0
cM a h (x:xs) | h==x = a+cM a h xs
              | otherwise = 0

dimensaodoMapa :: Mapa -> String
dimensaodoMapa l = mapaString (dimensaoMapa l)


dimensaoMapa :: Mapa -> Dimensao
dimensaoMapa [] = (0,0)
dimensaoMapa l = (nLi l , length (head l))

mapaString :: Dimensao -> String
mapaString (x,y) = "," ++ show y


total :: Mapa -> String
total l = constroiMSet' (comprimeMapa (retirarBordas l)) ++ dimensaodoMapa l

--- Comprime lista de Jogadores

comprimeJogador :: Jogador -> String
comprimeJogador (Jogador (x,y) d v l c) = show x ++ "," ++ show y ++ "," ++ show d ++ "," ++  show v ++ "," ++  show l ++ "," ++ show c

comprimirLista :: [Jogador] -> String
comprimirLista [] = []
comprimirLista [x] = comprimeJogador x
comprimirLista (h:t) = (comprimeJogador h) ++ "$" ++ comprimirLista t 

--- Comprime Lista de Disparos
comprimeDisparosCLH :: [Disparo] -> String
comprimeDisparosCLH [] = []
comprimeDisparosCLH [x] = comprimeDisparoCLH x
comprimeDisparosCLH (h:t) = (comprimeDisparoCLH h) ++ "$" ++(comprimeDisparosCLH t)

comprimeDisparoCLH :: Disparo -> String
comprimeDisparoCLH (DisparoCanhao x (a,b) d) = "A" ++ "," ++ show x ++ "," ++ show a ++ "," ++ show b ++ "," ++ show d 
comprimeDisparoCLH (DisparoLaser x (a,b) d) = "L" ++ "," ++ show x ++ "," ++ show a ++ "," ++ show b ++ "," ++ show d 
comprimeDisparoCLH (DisparoChoque x y) = "H" ++ "," ++ show x ++ "," ++ show y




-- | Descomprime um 'Estado' no formato textual utilizado pela função 'comprime'.
--
-- __NB:__ A função 'comprime' é válida de for possível recuperar o 'Estado' utilizando a função 'descomprime', i.e.:
--
-- prop> descomprime . comprime = id
--
-- __NB:__ Esta propriedade é particularmente válida para a solução pré-definida:
--
-- prop> read . show = id
descomprime :: String -> Estado
descomprime l = Estado (codigoFinalM (separarMapa l)) (descomprimeJogadores (separarJogadores l)) (selecionaDisparo (separarDisparo l))

---
separarMapa :: String -> String
separarMapa [] = []
separarMapa (h:t) | ord h /= ord ' ' = h:separarMapa t
                  | otherwise = []

separarJogadores :: String -> String
separarJogadores [] = []
separarJogadores (h:t) | ord h /= ord ' ' = separarJogadores t
                       | otherwise = separarMapa t

separarDisparo :: String -> String
separarDisparo [] = []
separarDisparo (h:t) | ord h /= ord ' ' = separarDisparo t
                     | otherwise = separarJogadores t

------Descomprimir o mapa

antesdaDesco :: String -> String
antesdaDesco [] = []
antesdaDesco (h:t) | (ord h) /= (ord ',') = h :antesdaDesco t
                   | otherwise = [] 

descomprimeDimensao :: String -> String
descomprimeDimensao [] = []
descomprimeDimensao (h:t) | (ord h) /= (ord ',') = descomprimeDimensao t
                          | otherwise = t


juncao :: String -> Int
juncao l | (length (buscaN (desco l)) == 1) = trans (buscaN (desco l))
         | otherwise = convert (trans2 (buscaN (desco l)))

--troco tudo para inteiros 
desco :: String -> [Int]
desco [] = []
desco (h:t) =  (ord h): desco t

trans :: [Int] -> Int
trans [x] = bin2dec [chr x] 

trans2 :: [Int] -> [Int]
trans2 [] = []
trans2 (h:t) = ([trans [h]] ++ trans2 t)

convert :: [Int] -> Int
convert [x] = x
convert (h:t) = read (concat (map show (h:t))) :: Int

--buscar as primeiros Inteiros
buscaN :: [Int] -> [Int]
buscaN [] = []
buscaN (h:t) | isDigit (chr h) = h:buscaN t
             | otherwise = []

bin2dec :: String -> Int
bin2dec "" = 0
bin2dec s = let l = length s - 1
            in bin2dec' s l
                   
bin2dec' :: String -> Int -> Int
bin2dec' "" _ = 0
bin2dec' (x:xs) l = (toInt x)*(2^l) + bin2dec' xs (l-1)
  
toInt :: Char -> Int
toInt c = ord c - ord '0'
--------------------
buscaL :: [Int] -> Char
buscaL (h:t) | isDigit (chr h) = buscaL t
             | otherwise = chr h

buscades :: String -> Char
buscades l = buscaL (desco l)

rest :: [Int] -> [Int]
rest [] = []
rest (h:t) | isDigit (chr h) = rest t
           | otherwise = (h:t)

encontra :: String -> Int
encontra [] = 0
encontra l = length (rest (desco l))

constrois :: String -> [(Int,Char)]
constrois [] = []
constrois l = (juncao l,buscades l) : constrois (drop (length l+1 - encontra l) l)

descomprimeEmSet :: String -> [(Int,Char)]
descomprimeEmSet [] = []
descomprimeEmSet l = constrois (antesdaDesco l)

-----------------
descomprimeADimensao :: String -> Int
descomprimeADimensao l = juncao (descomprimeDimensao l)

-------------------------------------------

descomprimes :: [(Int,Char)] -> [(Int,Peca)]
descomprimes [] = []
descomprimes ((a,b):t) | b == 'i' = (a,x) :descomprimes t
                      | b == 'd' = (a,y) :descomprimes t
                      | otherwise = (a,z) :descomprimes t
                      where x = Bloco Indestrutivel
                            y = Bloco Destrutivel
                            z = Vazia


descomp :: String -> [(Int,Peca)]
descomp [] = []
descomp l = descomprimes (descomprimeEmSet l)

--------------------------------------------
--Funcoes importantes : descomp e descomprimeADimensao

criacaoDoMapa :: [(Int,Peca)] -> [Peca]
criacaoDoMapa [] = []
criacaoDoMapa ((a,b):t) = (replicate a b)++criacaoDoMapa t 

insertExp :: Peca -> Int -> Int -> [Peca] -> [Peca]
insertExp k _ _ [] = [k]++[k]
insertExp k x y (h:t) | (y-2)/=0 = h:insertExp k x (y-1) t
                              | otherwise = k:k:insertExp k x x (h:t)


insertExtremidade :: [Peca] -> Int -> Peca -> [Peca]
insertExtremidade [] _ _ = []
insertExtremidade l y b = (replicate (y+1) b) ++ l ++ (replicate (y-1) b)


codigoFinal :: Peca -> Int -> String -> [Peca]
codigoFinal _ 0 _ = []
codigoFinal b x l = insertExtremidade (insertExp (Bloco Indestrutivel) x x (criacaoDoMapa (descomp l))) x (Bloco Indestrutivel)

setMapa :: String -> [Peca]
setMapa l = codigoFinal (Bloco Indestrutivel) (descomprimeADimensao l) l


codigoFinalM :: String -> Mapa
codigoFinalM [] = []
codigoFinalM l = matrizTrans (setMapa l) (descomprimeADimensao l)


---Descomprimir a lista de jogadores (funcoes importantes comprimirLista e descomprimeJogadores)

descomprimeJogador :: String -> Jogador
descomprimeJogador l = Jogador (juncao (selecionaJogadores l),juncao (descomprimeDimensao (selecionaJogadores l))) (convertc(take 1 (descomprimeDimensao (descomprimeDimensao (selecionaJogadores l))))) (juncao (descomprimeDimensao (descomprimeDimensao (descomprimeDimensao (selecionaJogadores l))))) (juncao (descomprimeDimensao (descomprimeDimensao (descomprimeDimensao (descomprimeDimensao (selecionaJogadores l)))))) (juncao (descomprimeDimensao (descomprimeDimensao (descomprimeDimensao (descomprimeDimensao (descomprimeDimensao (selecionaJogadores l)))))))

selecionaJogadores :: String  -> String
selecionaJogadores [] = [] 
selecionaJogadores (h:t) | ord h /= ord '$' = h:selecionaJogadores t
                         | otherwise = []

dropaJogador :: String -> String
dropaJogador [] = []
dropaJogador l = drop (length (selecionaJogadores l)+1) l

descomprimeJogadores :: String -> [Jogador]
descomprimeJogadores [] = []
descomprimeJogadores l = (descomprimeJogador (selecionaJogadores l)) : (descomprimeJogadores (dropaJogador l))

convertc :: String -> Direcao
convertc l = read l :: Direcao

--Descomprimir Disparos
selecionaDisparo :: String -> [Disparo]
selecionaDisparo [] = []
selecionaDisparo (h:t) | ord h == ord 'H' = divideH (selecionaJogadores (h:t)) : selecionaDisparo (dropaJogador (h:t))
                       | ord h == ord 'L' = divideL (selecionaJogadores (h:t)) : selecionaDisparo (dropaJogador (h:t))
                       | otherwise = divideA (selecionaJogadores (h:t)) : selecionaDisparo (dropaJogador (h:t))

divideH :: String -> Disparo
divideH l = DisparoChoque (juncao (descomprimeDimensao l)) (convertt (descomprimeDimensao (descomprimeDimensao l)))

divideL :: String -> Disparo
divideL l = DisparoLaser (juncao (descomprimeDimensao l)) (juncao (descomprimeDimensao (descomprimeDimensao l)),juncao (descomprimeDimensao (descomprimeDimensao (descomprimeDimensao l)))) (convertc (descomprimeDimensao (descomprimeDimensao (descomprimeDimensao (descomprimeDimensao l)))))

divideA :: String -> Disparo
divideA l = DisparoCanhao (juncao (descomprimeDimensao l)) (juncao (descomprimeDimensao (descomprimeDimensao l)),juncao (descomprimeDimensao (descomprimeDimensao (descomprimeDimensao l)))) (convertc (descomprimeDimensao (descomprimeDimensao (descomprimeDimensao (descomprimeDimensao l)))))

convertt :: String -> Ticks
convertt l = read l :: Ticks
















