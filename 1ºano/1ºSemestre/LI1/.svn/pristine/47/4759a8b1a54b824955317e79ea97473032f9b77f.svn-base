-- | Este mÃ³dulo define funÃ§Ãµes comuns da Tarefa 4 do trabalho prÃ¡tico.
module Tarefa4_2018li1g000 where

import LI11819
import Tarefa3_2018li1g002
import Tarefa0_2018li1g002
import Tarefa1_2018li1g002
import Tarefa2_2018li1g002

-- * Testes
-- | Testes unitÃ¡rios da Tarefa 4.
--
-- Cada teste Ã© um 'Estado'.
testesT4 :: [Estado]
testesT4 = []

-- * FunÃ§Ãµes principais da Tarefa 4.

-- | AvanÃ§a o 'Estado' do jogo um 'Tick' de tempo.
--
-- __NB:__ Apenas os 'Disparo's afetam o 'Estado' do jogo com o passar do tempo.
--
-- __NB:__ Deve chamar as funÃ§Ãµes 'tickChoques', 'tickCanhoes' e 'tickLasers' pela ordem definida.
tick :: Estado -- ^ O 'Estado' anterior.
     -> Estado -- ^ O 'Estado' apÃ³s um 'Tick'.
tick = tickChoques . tickCanhoes . tickLasers

-- | AvanÃ§a o 'Estado' do jogo um 'Tick' de tempo, considerando apenas os efeitos dos tiros de 'Laser' disparados.
tickLasers :: Estado -> Estado
tickLasers e = e{mapaEstado = mapaLaser (disparosEstado e) (mapaEstado e),jogadoresEstado = atualizaJogador (jogadoresEstado e) (jogadorLaser (disparosEstado e) (mapaEstado e))}

-- | AvanÃ§a o 'Estado' do jogo um 'Tick' de tempo, considerando apenas os efeitos das balas de 'Canhao' disparadas.
tickCanhoes :: Estado -> Estado
tickCanhoes = undefined

-- | AvanÃ§a o 'Estado' do jogo um 'Tick' de tempo, considerando apenas os efeitos dos campos de 'Choque' disparados.
tickChoques :: Estado -> Estado
tickChoques e = e{disparosEstado = separaDisparos (disparosEstado e)}

-- Choque
separaDisparos :: [Disparo] -> [Disparo]
separaDisparos [] = []
separaDisparos ((DisparoChoque x y):t) | y <= 0 = separaDisparos t
                                       | otherwise = (DisparoChoque x (y-1)) : separaDisparos t 
separaDisparos ((DisparoCanhao a (x,y) b):t) = separaDisparos t
separaDisparos ((DisparoLaser a (x,y) b):t) = separaDisparos t

---- Laser (mapa)
mapaLaser :: [Disparo] -> Mapa -> Mapa
mapaLaser [] m = m
mapaLaser (h:t) m =  mapaLaser t (posicaoVazia (laserPosicao h m) Vazia m)

laserPosicao :: Disparo -> Mapa -> [Posicao]
laserPosicao (DisparoLaser a (x,y) D) m | paraLaser (x,y+1) m = (x,y+1) : laserPosicao (DisparoLaser a (x,y+1) D) m
                                        | otherwise = []
laserPosicao (DisparoLaser a (x,y) E) m | paraLaser (x,y-1) m = (x,y-1) : laserPosicao (DisparoLaser a (x,y-1) E) m
                                        | otherwise = []
laserPosicao (DisparoLaser a (x,y) B) m | paraLaser (x+1,y) m = (x+1,y) : laserPosicao (DisparoLaser a (x+1,y) B) m
                                        | otherwise = []
laserPosicao (DisparoLaser a (x,y) C) m | paraLaser (x-1,y) m = (x-1,y) : laserPosicao (DisparoLaser a (x-1,y) C) m
                                        | otherwise = []

paraLaser :: Posicao -> Mapa -> Bool
paraLaser (0,0) ((h:t):ts) | h== Vazia = True
                           | h== Bloco Destrutivel = True
                           | otherwise = False
paraLaser _ [[]] = False
paraLaser (0,y) ((h:t):ts) = paraLaser (0,y-1) (t:ts)
paraLaser (x,y) ((h:t):ts) = paraLaser (x-1,y) ts

posicaoVazia :: [Posicao] -> Peca -> Mapa -> Mapa
posicaoVazia [] _ m = m
posicaoVazia (h:t) Vazia m = posicaoVazia t Vazia (atualizaPosicaoMatriz h Vazia m) 

-- Laser (Jogadores)
jogadorLaser :: [Disparo] -> Mapa ->[Posicao]
jogadorLaser [] m = []
jogadorLaser (h:t) m = (laserPosicao h m) ++ jogadorLaser t m

atualizaJogador :: [Jogador] -> [Posicao] -> [Jogador]
atualizaJogador x [] = x
atualizaJogador [] _ = []
atualizaJogador (h:t) p = (reduzirVida h p) : atualizaJogador t p

reduzirVida :: Jogador -> [Posicao] -> Jogador
reduzirVida x [] = x
reduzirVida (Jogador (x,y) d v l c) (h:t) | v>0 && (estaNaMesmaPos (x,y) h) = (Jogador (x,y) d (v-1) l c)
                                            | otherwise = reduzirVida (Jogador (x,y) d v l c) t

estaNaMesmaPos :: Posicao -> Posicao -> Bool
estaNaMesmaPos (x,y) (a,b) | (x,y) == (a,b) || (x+1,y) == (a,b) || (x,y+1) == (a,b) || (x+1,y+1) == (a,b) = True
                           | otherwise = False





{--colisao :: Disparo -> [Disparo] -> [Disparo]
colisao x [] = [x]
colisao (DisparoCanhao a (x,y) b) ((DisparoCanhao c (w,z) d):t) | x==w && y==z = colisao t
                                                                | otherwise = (DisparoCanhao c (w,z) d) : colisao (DisparoCanhao a (x,y) b) t
colisao (DisparoCanhao a (x,y) b) ((DisparoLaser c (w,z) d):t) | x==w && y==z = colisao t
                                                               | otherwise = (DisparoLaser c (w,z) d) : colisao (DisparoCanhao a (x,y) b) t



atualizaDisparo :: Posicao -> Direcao -> Posicao
atualizaDisparo (x,y) D = (x,y+1)
atualizaDisparo (x,y) E = (x,y-1)
atualizaDisparo (x,y) C = (x-1,y)
atualizaDisparo (x,y) B = (x+1,y)--}














