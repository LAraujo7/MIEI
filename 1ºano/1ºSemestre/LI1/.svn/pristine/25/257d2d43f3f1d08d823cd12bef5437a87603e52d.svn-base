-- | Este módulo define funções comuns da Tarefa 5 do trabalho prático.
module Main where

import Graphics.Gloss
import Graphics.Gloss.Interface.Pure.Game
import Graphics.Gloss.Juicy
import Graphics.Gloss.Data.ViewPort
import Data.List (transpose)
import LI11819
import Tarefa4_2018li1g002
import Tarefa3_2018li1g002
import Tarefa2_2018li1g002
import Tarefa1_2018li1g002
import Tarefa0_2018li1g002


data EstadoGloss = EstadoGloss 
     { estadoJogo :: Estado
     , estadoJogadores :: [Picture]
     , pictureCanhao :: [Picture]
     , pictureLaser :: [Picture]
     , pictureChoque :: [Picture]
     , pictureMapa :: (Picture,Picture,Picture)
     , pictureBackGroung :: Picture
     , jogadoresVivos :: [Int]
     , estadoKey :: [(Int,Jogada)]}


main :: IO ()
main = do i <- loadJuicy "paredeI.png"
          d <- loadJuicy "paredeD.png"
          v <- loadJuicy "Vazia.png"
          b <- loadJuicy "background.png"
          play dm                   -- janela onde irá correr o jogo
                (greyN 0.5)             -- côr do fundo da janela
                fr                      -- frame rate
                (estadoGlossInicial i d v b) -- estado inicial
                desenhaEstadoGloss      -- desenha o estado do jogo
                reageEventoGloss       -- reage a um evento
                reageTempoGloss         -- reage ao passar do tempo


fr :: Int
fr = 10


dm :: Display
dm = InWindow "Game of Tanks" (1280, 768) (200, 200)

estadoGlossInicial ::  Maybe Picture -> Maybe Picture -> Maybe Picture -> Maybe Picture -> EstadoGloss
estadoGlossInicial (Just i) (Just d) (Just v) (Just b) = (EstadoGloss (Estado (mapaInicial (30,30)) [(Jogador (1,1) D 6 3 3),(Jogador (1,27) B 6 3 3),(Jogador (27,27) E 6 3 3),(Jogador (27,1) C 6 3 3)] []) [jogadorPicture 0,jogadorPicture 1,jogadorPicture 2,jogadorPicture 3] [disparoCanhao 0,disparoCanhao 1,disparoCanhao 2,disparoCanhao 3] [disparoLaser 0,disparoLaser 1,disparoLaser 2,disparoLaser 3] [disparoChoque 0,disparoChoque 1,disparoChoque 2,disparoChoque 3] (i,d,v) b [0,1,2,3] [])
estadoGlossInicial _ _ _ _ = (EstadoGloss (Estado (mapaInicial (0,0)) [] []) [] [] [] [] (Blank,Blank,Blank) Blank [] [])

jogadorPicture :: Int -> Picture
jogadorPicture i = Color (escolheCor i) (Polygon [(0,0),(2,0),(2,2),(0,2),(0,0)])

disparoCanhao :: Int -> Picture
disparoCanhao i = Color (escolheCor i) (Polygon [(0,0),(2,0),(1,1),(0,0)])

disparoLaser :: Int -> Picture
disparoLaser i = Color (escolheCor i) (Polygon [(0,0),(1,0),(1,1),(0,1),(0,0)])

disparoChoque :: Int -> Picture
disparoChoque i = Color (escolheCor i) (Line [(4,4),(4,-2),(-2,-2),(-2,4),(4,4)])

escolheCor :: Int -> Color
escolheCor 0 = red
escolheCor 1 = green
escolheCor 2 = white
escolheCor 3 = orange

desenhaEstadoGloss :: EstadoGloss -> Picture
desenhaEstadoGloss (EstadoGloss (Estado m j d) ej c l eh (i,ds,v) b h ls)
                                | length h == 0 = Pictures [Scale (0.5) (0.5) $ Color black $ text "Empate!"]
                                | length h == 1 = Pictures [Scale (0.5) (0.5) $ Color black $ text "VENCEU!"]
                                | otherwise = applyViewPortToPicture (initialViewport)
                                          (Pictures [applyViewPortToPicture (backGroundViewPort) b,      -- background picture
                                          (lenght(pegaImagem m (i,ds,v))),                               -- picture do mapa
--                                          applyViewPortToPicture (jogoViewPort) 
                                          (Pictures (desenhaJogadores j h ej)),                                     -- picture dos jogadores
                                          (Pictures (desenhaDisparoCanhao d c)),                        -- picture dos disparos canhao
                                          (Pictures (desenhaDisparoLaser d m l)),                       -- picture dos disparos laser
                                          (Pictures (desenhaDisparoChoque d j eh)),                        -- picture dos disparos choque
                                          (Translate 60 0 fundo),
                                          Pictures (desenhaSideBar 0 60 0 j ej)
                                          ])




{--            Desenha Mapa                --}


pegaImagem :: Mapa -> (Picture,Picture,Picture) -> [[Picture]]
pegaImagem [] m = []
pegaImagem (h:t) m = (construir h m) : pegaImagem t m

construir :: [Peca] -> (Picture,Picture,Picture) -> [Picture]
construir [] _ = []
construir (h:t) (i,d,v) | h == Vazia = (applyViewPortToPicture (pecaViewPort) v) : construir t (i,d,v)
                        | h == Bloco Indestrutivel = (applyViewPortToPicture (pecaViewPort) i) : construir t (i,d,v)
                        | otherwise = (applyViewPortToPicture (pecaViewPort) d) : construir t (i,d,v)

lenght :: [[Picture]] -> Picture
lenght m = Pictures (funcAux m (0,40))

funcAux :: [[Picture]] -> (Float,Float) -> [Picture]
funcAux [] _ = []
funcAux ([]:t) (x,y) = funcAux t (0,(y-2))
funcAux ((h:t):s) (x,y) = (Translate x y h) : funcAux (t:s) ((x+2),y)




{--            Desenha Jogadores         --}


desenhaJogadores :: [Jogador] -> [Int] -> [Picture] -> [Picture]
desenhaJogadores [] _ _ = []
desenhaJogadores (h:t) (i:is) (p:ps) = (desenhaJAux h i p) : desenhaJogadores t is ps

desenhaJAux :: Jogador -> Int -> Picture -> Picture
desenhaJAux (Jogador (x,y) d v l c) i p | v>0 = (Translate (convertFloat x) (convertFloat y) p)
                                        | otherwise = Blank

convertFloat :: Int -> Float
convertFloat x = fromIntegral x :: Float


{--        Desenha Disparos Canhao      --}


desenhaDisparoCanhao :: [Disparo] -> [Picture] -> [Picture]
desenhaDisparoCanhao [] _ = []
desenhaDisparoCanhao ((DisparoCanhao i (x,y) d):t) p = (desenhaCAux (DisparoCanhao i (x,y) d) (encontraIndiceLista i p)) : desenhaDisparoCanhao t p
desenhaDisparoCanhao (_:t) p = desenhaDisparoCanhao t p

desenhaCAux :: Disparo -> Picture -> Picture
desenhaCAux (DisparoCanhao i (x,y) d) p | d == C = Translate (convertFloat x+2) (convertFloat y) (Rotate 270 p)
                                        | d == D = Translate (convertFloat x) (convertFloat y) p
                                        | d == B = Translate (convertFloat x+1) (convertFloat y+2) (Rotate 90 p)
                                        | otherwise = Translate (convertFloat x+2) (convertFloat y+1) (Rotate 180 p)


{--        Desenha Disparos Laser      --}


desenhaDisparoLaser :: [Disparo] -> Mapa -> [Picture] -> [Picture]
desenhaDisparoLaser [] _ _ = []
desenhaDisparoLaser ((DisparoLaser i (x,y) d):t) m p = Pictures (printLaser (laserPosicao (DisparoLaser i (x,y) d) m) (encontraIndiceLista i p)) : desenhaDisparoLaser t m p
desenhaDisparoLaser (_:t) m p = desenhaDisparoLaser t m p

printLaser :: [Posicao] -> Picture -> [Picture]
printLaser [] _ = []
printLaser ((x,y):t) p = Translate (convertFloat x) (convertFloat y) p : printLaser t p


{--         Desenha Disparos Choque      --}


desenhaDisparoChoque :: [Disparo] -> [Jogador] -> [Picture] -> [Picture]
desenhaDisparoChoque [] _ _ = []
desenhaDisparoChoque ((DisparoChoque i t):ts) j p = (desenhaChoque (encontraIndiceLista i j) (encontraIndiceLista i p)) : desenhaDisparoChoque ts j p
desenhaDisparoChoque (_:t) j p = desenhaDisparoChoque t j p

desenhaChoque :: Jogador -> Picture -> Picture
desenhaChoque (Jogador (x,y) d v l c) p = Translate (convertFloat x) (convertFloat y) p


{--         Desenha SideBar      --}


desenhaSideBar :: Int -> Float -> Float -> [Jogador] -> [Picture] -> [Picture]
desenhaSideBar _ _ _ [] _ = []
desenhaSideBar k a b ((Jogador (x,y) d v l c):t) (p:ps) = Translate a b (jogador1 k v l c) : desenhaSideBar (k+1) a (b-20) t ps 

fundo :: Picture
fundo = Color azure (Polygon [(40,40),(40,-40),(0,-40),(0,40),(40,40)])


jogador1 :: Int -> Int -> Int -> Int -> Picture
jogador1 a x y z = Pictures [Translate 4 36 jogadorText,(Translate 20 36 (jogadorPicture a)),Translate 5 31 (vidaJ1 x),Translate 5 26 (nLaser1 y),Translate 5 21 (nChoque1 z)]

jogadorText :: Picture
jogadorText = Scale (0.02) (0.02) $ Color black $ text ("Jogador : ")

vidaJ1 :: Int -> Picture
vidaJ1 x = Scale (0.02) (0.02) $ Color black $ text ("Vidas : " ++ (show x))

nLaser1 :: Int -> Picture
nLaser1 x = Scale (0.02) (0.02) $ Color black $ text ("Disparos Laser : " ++ (show x))

nChoque1 :: Int -> Picture
nChoque1 x = Scale (0.02) (0.02) $ Color black $ text ("Disparos Choque : " ++ (show x))







{-- Reage a um evento que vai alterar o estado do jogo --}


reageEventoGloss :: Event -> EstadoGloss -> EstadoGloss
reageEventoGloss (EventKey (SpecialKey KeyEnter) Down _ _) (EstadoGloss a b c d e (k,w,z) g h i) = estadoGlossInicial (Just k) (Just w) (Just z) (Just g)

reageEventoGloss (EventKey (SpecialKey KeyUp) Down _ _) e = e{estadoKey = acrescentaK (0,Movimenta D) (estadoKey e)}
reageEventoGloss (EventKey (SpecialKey KeyUp) Up _ _) e = e{estadoKey = removeK (0,Movimenta D) (estadoKey e)}

reageEventoGloss (EventKey (SpecialKey KeyDown) Down _ _) e = e{estadoKey = acrescentaK (0,Movimenta E) (estadoKey e)}
reageEventoGloss (EventKey (SpecialKey KeyDown) Up _ _) e = e{estadoKey = removeK (0,Movimenta E) (estadoKey e)}

reageEventoGloss (EventKey (SpecialKey KeyLeft) Down _ _) e = e{estadoKey = acrescentaK (0,Movimenta C) (estadoKey e)}
reageEventoGloss (EventKey (SpecialKey KeyLeft) Up _ _) e = e{estadoKey = removeK (0,Movimenta C) (estadoKey e)}

reageEventoGloss (EventKey (SpecialKey KeyRight) Down _ _) e = e{estadoKey = acrescentaK (0,Movimenta B) (estadoKey e)}
reageEventoGloss (EventKey (SpecialKey KeyRight) Up _ _) e = e{estadoKey = removeK (0,Movimenta B) (estadoKey e)}

reageEventoGloss (EventKey (Char ',') Down _ _) e = e{estadoKey = acrescentaK (0,Dispara Canhao) (estadoKey e)}
reageEventoGloss (EventKey (Char ',') Up _ _) e = e{estadoKey = removeK (0,Dispara Canhao) (estadoKey e)}

reageEventoGloss (EventKey (Char '.') Down _ _) e = e{estadoKey = acrescentaK (0,Dispara Laser) (estadoKey e)}
reageEventoGloss (EventKey (Char '.') Up _ _) e = e{estadoKey = removeK (0,Dispara Laser) (estadoKey e)}

reageEventoGloss (EventKey (Char '-') Down _ _) e = e{estadoKey = acrescentaK (0,Dispara Choque) (estadoKey e)}
reageEventoGloss (EventKey (Char '-') Up _ _) e = e{estadoKey = removeK (0,Dispara Choque) (estadoKey e)}


reageEventoGloss (EventKey (Char 'w') Down _ _) e = e{estadoKey = acrescentaK (1,Movimenta D) (estadoKey e)}
reageEventoGloss (EventKey (Char 'w') Up _ _) e = e{estadoKey = removeK (1,Movimenta D) (estadoKey e)}

reageEventoGloss (EventKey (Char 's') Down _ _) e = e{estadoKey = acrescentaK (1,Movimenta E) (estadoKey e)}
reageEventoGloss (EventKey (Char 's') Up _ _) e = e{estadoKey = removeK (1,Movimenta E) (estadoKey e)}

reageEventoGloss (EventKey (Char 'a') Down _ _) e = e{estadoKey = acrescentaK (1,Movimenta C) (estadoKey e)}
reageEventoGloss (EventKey (Char 'a') Up _ _) e = e{estadoKey = removeK (1,Movimenta C) (estadoKey e)}

reageEventoGloss (EventKey (Char 'd') Down _ _) e = e{estadoKey = acrescentaK (1,Movimenta B) (estadoKey e)}
reageEventoGloss (EventKey (Char 'd') Up _ _) e = e{estadoKey = removeK (1,Movimenta B) (estadoKey e)}

reageEventoGloss (EventKey (Char '1') Down _ _) e = e{estadoKey = acrescentaK (1,Dispara Canhao) (estadoKey e)}
reageEventoGloss (EventKey (Char '1') Up _ _) e = e{estadoKey = removeK (1,Dispara Canhao) (estadoKey e)}

reageEventoGloss (EventKey (Char '2') Down _ _) e = e{estadoKey = acrescentaK (1,Dispara Laser) (estadoKey e)}
reageEventoGloss (EventKey (Char '2') Up _ _) e = e{estadoKey = removeK (1,Dispara Laser) (estadoKey e)}

reageEventoGloss (EventKey (Char '3') Down _ _) e = e{estadoKey = acrescentaK (1,Dispara Choque) (estadoKey e)}
reageEventoGloss (EventKey (Char '3') Up _ _) e = e{estadoKey = removeK (1,Dispara Choque) (estadoKey e)}

reageEventoGloss _ s = s -- ignora qualquer outro evento 



efetuaJogada :: Estado -> [(Int,Jogada)] -> Estado
efetuaJogada e [] = e
efetuaJogada e (h:t) = efetuaJogada (jogada (fst h) (snd h) e) t

acrescentaK :: (Int,Jogada) -> [(Int,Jogada)] -> [(Int,Jogada)]
acrescentaK x [] = [x]
acrescentaK x l | elem x l = l
                | otherwise = [x]++l

removeK :: (Int,Jogada) -> [(Int,Jogada)] -> [(Int,Jogada)]
removeK _ [] = []
removeK x (h:t) | x == h = t
                | otherwise = h : removeK x t



reageTempoGloss :: Float -> EstadoGloss -> EstadoGloss
reageTempoGloss n e = e{estadoJogo = tick (efetuaJogada (estadoJogo e) (estadoKey e)), jogadoresVivos = listaVivos (estadoJogo e) (jogadoresVivos e)}





listaVivos :: Estado -> [Int] -> [Int]
listaVivos (Estado m [] d) _ = []
listaVivos (Estado m ((Jogador (x,y) d v l c):t) i) (h:ts) | v == 0 = listaVivos (Estado m t i) ts
                                                           | otherwise = h : listaVivos (Estado m t i) ts









jogoViewPort :: ViewPort
jogoViewPort = ViewPort { viewPortTranslate = (-10.6, -9.5), viewPortRotate = 0, viewPortScale = 2 }

initialViewport :: ViewPort
initialViewport = ViewPort { viewPortTranslate = (-50, 0), viewPortRotate = 0, viewPortScale = 8 }



pecaViewPort :: ViewPort
pecaViewPort = ViewPort { viewPortTranslate = (-400,0), viewPortRotate = 0, viewPortScale = 0.05 }

backGroundViewPort :: ViewPort
backGroundViewPort = ViewPort { viewPortTranslate = (50,0), viewPortRotate = 0, viewPortScale = 0.2 }




