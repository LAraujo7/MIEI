-- | Este módulo define funções comuns da Tarefa 3 do trabalho prático.
module Tarefa3_2018li1g002 where

import LI11819
import Data.Char

-- * Testes

-- | Testes unitários da Tarefa 3.
--
-- Cada teste é um 'Estado'.
testesT3 :: [Estado]
testesT3 = []

-- * Funções principais da Tarefa 3.

-- | Comprime um 'Estado' para formato textual.
--
-- __NB:__ A função 'show' representa um 'Estado' num formato textual facilmente legível mas extenso.
--
-- __NB:__ Uma boa solução deve representar o 'Estado' dado no mínimo número de caracteres possível.
--comprime :: Estado -> String
--comprime e = constroiMSet' (comprimeMapa (antesDeComprimir mapaEstado e)) ++ "/"











-- Comprime o Mapa 
antesDeComprimir :: Mapa -> Mapa
antesDeComprimir [] = []
antesDeComprimir l = aDC (drop 1 l)

aDC :: Mapa -> Mapa
aDC [] = []
aDC l = retirar1C (take ((length l)-1) l)

retirar1C :: Mapa -> Mapa
retirar1C [] = []
retirar1C (h:t) = retirar2C ((drop 1 h):retirar1C t)

retirar2C :: Mapa -> Mapa
retirar2C [] = []
retirar2C (h:t) = (take ((length h)-1) h):retirar2C t


comprimeMapa :: Mapa -> String
comprimeMapa [] = []
comprimeMapa (l:t) = (comprimeLinha l) ++ comprimeMapa t

comprimeLinha :: [Peca] -> String
comprimeLinha [] = []
comprimeLinha (h:t) | h == x = "i" ++ comprimeLinha t
                    | h == y = "d" ++ comprimeLinha t
                    | otherwise = "v" ++ comprimeLinha t
                    where x = Bloco Indestrutivel
                          y = Bloco Destrutivel

constroiMSet' :: String -> String
constroiMSet' [] = []
constroiMSet' (h:t) = show ((cM 1 h t)+1) ++ [h] ++ constroiMSet' (drop (cM 1 h t) t)

cM :: Int -> Char -> String -> Int
cM x h [] = 0
cM a h (x:xs) | h==x = a+cM a h xs
              | otherwise = 0
---



-- | Descomprime um 'Estado' no formato textual utilizado pela função 'comprime'.
--
-- __NB:__ A função 'comprime' é válida de for possível recuperar o 'Estado' utilizando a função 'descomprime', i.e.:
--
-- prop> descomprime . comprime = id
--
-- __NB:__ Esta propriedade é particularmente válida para a solução pré-definida:
--
-- prop> read . show = id
descomprime :: String -> Estado
descomprime = read

juncao :: String -> Int
juncao l | (length (buscaN (desco l)) == 1) = trans (buscaN (desco l))
         | otherwise = convert (trans2 (buscaN (desco l)))

--troco tudo para inteiros 
desco :: String -> [Int]
desco [] = []
desco (h:t) =  (ord h): desco t

trans :: [Int] -> Int
trans [x] = bin2dec [chr x] 

trans2 :: [Int] -> [Int]
trans2 [] = []
trans2 (h:t) = ([trans [h]] ++ trans2 t)

convert :: [Int] -> Int
convert [x] = x
convert (h:t) = read (concat (map show (h:t))) :: Int

--buscar as primeiros Inteiros
buscaN :: [Int] -> [Int]
buscaN [] = []
buscaN (h:t) | isDigit (chr h) = h:buscaN t
             | otherwise = []

bin2dec :: String -> Int
bin2dec "" = 0
bin2dec s = let l = length s - 1
            in bin2dec' s l
                   
bin2dec' :: String -> Int -> Int
bin2dec' "" _ = 0
bin2dec' (x:xs) l = (toInt x)*(2^l) + bin2dec' xs (l-1)
  
toInt :: Char -> Int
toInt c = ord c - ord '0'
--------------------
buscaL :: [Int] -> Char
buscaL (h:t) | isDigit (chr h) = buscaL t
             | otherwise = chr h

buscades :: String -> Char
buscades l = buscaL (desco l)

rest :: [Int] -> [Int]
rest [] = []
rest (h:t) | isDigit (chr h) = rest t
           | otherwise = (h:t)

encontra :: String -> Int
encontra [] = 0
encontra l = length (rest (desco l))

-----------------
constroi :: String -> [(Int,Char)]
constroi [] = []
constroi l = (juncao l,buscades l) : constroi (drop (length l+1 - encontra l) l)

-------------------------------------------

descomprime :: [(Int,Char)] -> [(Int,Peca)]
descomprime [] = []
descomprime ((a,b):t) | b == 'i' = (a,x) :descomprime t
                      | b == 'd' = (a,y) :descomprime t
                      | otherwise = (a,z) :descomprime t
                      where x = Bloco Indestrutivel
                            y = Bloco Destrutivel
                            z = Vazia


descomp :: String -> [(Int,Peca)]
descomp [] = []
descomp l = descomprime (constroi l)




